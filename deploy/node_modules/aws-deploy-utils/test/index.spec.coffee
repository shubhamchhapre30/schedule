sinon       = require 'sinon'
q           = require 'q'
_           = require 'underscore'
AWS         = require 'aws-sdk'
logger      = require 'winston'
DeployUtils = require '../build/deploy.js'

describe 'aws-deploy-utils', ->
  existingEnvName = "existing environment name"
  deployUtils = null
  origAwsElasticBeanstalk = null
  stubbedBeanstalkDeploy = null
  stubbedGetAllEnvironmentsWithCname = null
  stubbedGetElbNameByEnvironmentName = null
  stubbedSwapEnvironmentCnames = null
  environmentType = 'unit-test'
  applicationName = 'test-aws-app'
  awsCredentials = {
    accessKeyId: 'blah'
    secretAccessKey: 'meh'
    region: 'woot'
  }
  deployParameters =
    environmentType: environmentType
    awsKeysFilePath: 'keys/aws-unit-keys.yml'
    archiveFilePath: 'artifacts/unit-test-version.zip'
    environmentName: "#{applicationName}-#{environmentType}"
    beanstalkConfigFilePath: 'config/beanstalk/unit-test.config'
    outputPath: 'artifacts'
    awsStackName: '64bit Amazon Linux -- UNIT TEST -- running Node.js'
    alarmsConfiguration: []

  beforeEach ->
    sinon.stub logger, 'error'
    sinon.stub logger, 'info'
    sinon.stub(DeployUtils.prototype, 'getUniqueSuffix').returns 'notsounique'
    stubbedBeanstalkDeploy = sinon.stub(DeployUtils.prototype, 'beanstalkDeploy').returns q.reject 'default stubbed beanstalkDeploy method'
    stubbedGetElbNameByEnvironmentName = sinon.stub(DeployUtils.prototype, 'getElbNameByEnvironmentName').returns q.reject 'default stubbed getElbNameByEnvironmentName method'
    stubbedSwapEnvironmentCnames = sinon.stub(DeployUtils.prototype, 'swapEnvironmentCnames').returns q.reject 'default stubbed swapEnvironmentCnames method'

    stubbedGetAllEnvironmentsWithCname = sinon.stub(DeployUtils.prototype, 'getAllEnvironmentsWithCname').returns q.reject 'default stubbed getAllEnvironmentsWithCname method'
    stubbedGetAllEnvironmentsWithCname.withArgs("#{deployParameters.environmentName}").returns q.resolve []

    deployUtils = new DeployUtils {
      elasticBeanstalkAppName: applicationName
      awsAccessKeyId: awsCredentials.accessKeyId
      awsSecretAccessKey: awsCredentials.secretAccessKey
      awsRegion: awsCredentials.region
    }

    origAwsElasticBeanstalk = deployUtils.awsElasticBeanstalk
    stubbedAwsElasticBeanstalk =
      describeEnvironments: sinon.stub().returns (params..., cb) -> cb('default stubbed method for aws.describeEnvironments')
      swapEnvironmentCNAMEs: sinon.stub().returns (params..., cb) -> cb('default stubbed method for aws.swapEnvironmentCNAMEs')
      terminateEnvironment: sinon.stub().returns (params..., cb) -> cb('default stubbed method for aws.terminateEnvironment')
      describeEnvironmentResources: sinon.stub().returns (params..., cb) -> cb('default stubbed method for aws.describeEnvironmentResources')

    deployUtils.awsElasticBeanstalk = stubbedAwsElasticBeanstalk

  afterEach ->
    deployUtils.awsElasticBeanstalk = origAwsElasticBeanstalk
    DeployUtils.prototype.getUniqueSuffix.restore()
    stubbedBeanstalkDeploy.restore()
    stubbedGetAllEnvironmentsWithCname.restore()
    stubbedGetElbNameByEnvironmentName.restore()
    stubbedSwapEnvironmentCnames.restore()
    logger.error.restore()
    logger.info.restore()

  it 'Should throw error if the AWS Application is not specified', ->
    fn = ->
      new DeployUtils {
        elasticBeanstalkAppName: ''
        awsAccessKeyId: awsCredentials.accessKeyId
        awsSecretAccessKey: awsCredentials.secretAccessKey
        awsRegion: awsCredentials.region
      }
    expect(fn).to.throw 'Elastic Beanstalk Application Name is required'

  it 'Should throw error if the AWS Application is empty', ->
    fn = ->
      new DeployUtils {
        awsAccessKeyId: awsCredentials.accessKeyId
        awsSecretAccessKey: awsCredentials.secretAccessKey
        awsRegion: awsCredentials.region
      }
    expect(fn).to.throw 'Elastic Beanstalk Application Name is required'

  context 'When doing a deployment (Deploy Unique Environment)', ->

    beforeEach ->
      @expectedParameters =
        awsKeysFilePath: deployParameters.awsKeysFilePath
        archiveFilePath: deployParameters.archiveFilePath
        environmentName: "#{deployParameters.environmentName}-notsounique"
        beanstalkConfigFilePath: deployParameters.beanstalkConfigFilePath
        outputPath: deployParameters.outputPath
        awsStackName: deployParameters.awsStackName

      stubbedBeanstalkDeploy.withArgs(@expectedParameters).returns q.resolve 'successful deployment'

    it 'should deploy a new environment with a generated cname that match the environment name', (next) ->
      deployUtils.deployUniqueEnvironment(deployParameters).should.be.fulfilled.then (response) ->
        expect(response).to.deep.equal 'successful deployment'
      .should.notify next

  context 'When doing a blue/green deployment', ->
    beforeEach ->
      @expectedParameters =
        awsKeysFilePath: deployParameters.awsKeysFilePath
        archiveFilePath: deployParameters.archiveFilePath
        environmentName: "#{deployParameters.environmentName}"
        beanstalkConfigFilePath: deployParameters.beanstalkConfigFilePath
        outputPath: deployParameters.outputPath
        awsStackName: deployParameters.awsStackName
        alarmsConfiguration: deployParameters.alarmsConfiguration

      stubbedBeanstalkDeploy.withArgs(@expectedParameters).returns q.resolve 'successful deployment'
      stubbedGetElbNameByEnvironmentName.withArgs(deployParameters.environmentName).returns q.resolve "elb.#{deployParameters.environmentName}"

    it 'should check if the taget cname is availble', (next) ->
      deployUtils.deployBlueGreen(deployParameters).should.be.fulfilled.then (response) ->
        expect(response).to.deep.equal 'test-aws-app-unit-test has been deployed successfuly'
      .should.notify next

    context 'When the target cname is NOT available', ->
      beforeEach ->
        stubbedGetAllEnvironmentsWithCname.withArgs("#{applicationName}-#{environmentType}-\\w*").returns q.resolve []
        stubbedGetAllEnvironmentsWithCname.withArgs("#{deployParameters.environmentName}").returns q.resolve [
          CNAME: "#{deployParameters.environmentName}.elb.com"
          EnvironmentName: existingEnvName
        ]

        @expectedParameters =
          awsKeysFilePath: deployParameters.awsKeysFilePath
          archiveFilePath: deployParameters.archiveFilePath
          environmentName: "#{deployParameters.environmentName}-notsounique"
          beanstalkConfigFilePath: deployParameters.beanstalkConfigFilePath
          outputPath: deployParameters.outputPath
          awsStackName: deployParameters.awsStackName
          alarmsConfiguration: deployParameters.alarmsConfiguration

        @cnameSwapParameters =
          fromOldEnvName: existingEnvName
          toNewEnvName: @expectedParameters.environmentName
          alarmsConfiguration: deployParameters.alarmsConfiguration

        stubbedBeanstalkDeploy.withArgs(@expectedParameters).returns q.resolve 'successful deployment'
        stubbedSwapEnvironmentCnames.withArgs(@cnameSwapParameters).returns q.resolve 'cname swap successful'

      it '
      Should deploy a new environment with a generated cname that match the environment name,
      Should swap cname between the exising environment and the new environment,
      Should terminate all other (zombies) environments of the same type', (next) ->
        deployUtils.deployBlueGreen(deployParameters).should.be.fulfilled.then (response) ->
          expect(response).to.deep.equal "#{deployParameters.environmentName}-notsounique has been deployed (blue/green) successfuly"
        .should.notify next

    context 'When the target cname is available', ->
      beforeEach ->
        stubbedGetAllEnvironmentsWithCname.withArgs("#{deployParameters.environmentName}").returns q.resolve []

        @expectedParameters =
          awsKeysFilePath: deployParameters.awsKeysFilePath
          archiveFilePath: deployParameters.archiveFilePath
          environmentName: "#{deployParameters.environmentName}-notsounique"
          beanstalkConfigFilePath: deployParameters.beanstalkConfigFilePath
          outputPath: deployParameters.outputPath
          awsStackName: deployParameters.awsStackName
          alarmsConfiguration: deployParameters.alarmsConfiguration

        stubbedBeanstalkDeploy.withArgs(@expectedParameters).returns q.resolve 'successful deployment'

      it 'should deploy the new environment with the given target cname', (next) ->
        deployUtils.deployBlueGreen(deployParameters).should.be.fulfilled.then (response) ->
          expect(response).to.deep.equal "#{deployParameters.environmentName} has been deployed successfuly"
        .should.notify next

  context 'When swapping CNAMES', ->
    stubbedWaitUntilEnvironmentIsHealthy = null
    stubbedWaitForDnsToPropagate = null
    stubbedGetCloudWatchAlarmNamesByEnvironmentPrefix = null
    stubbedDeleteCloudWatchAlarms = null
    stubbedCreateCloudWatchAlarms = null

    existingAlarms = [
      'alarm1', 'alarm2'
    ]
    newAlarms = [
      'alarmNew1', 'alarmNew2'
    ]
    newElbName = 'New Environment ELB Name'
    swapParameters =
      fromOldEnvName: 'old-environemnt'
      toNewEnvName: 'new-environment'
      alarmsConfiguration: newAlarms

    beforeEach ->
      stubbedWaitUntilEnvironmentIsHealthy = sinon.stub(DeployUtils.prototype, 'waitUntilEnvironmentIsHealthy').returns q.reject 'default stubbed method for waitUntilEnvironmentIsHealthy'
      stubbedWaitForDnsToPropagate = sinon.stub(DeployUtils.prototype, 'waitForDnsToPropagate').returns q.reject 'default stubbed method for waitForDnsToPropagate'
      stubbedGetCloudWatchAlarmNamesByEnvironmentPrefix = sinon.stub(DeployUtils.prototype, 'getCloudWatchAlarmNamesByEnvironmentPrefix').returns q.reject 'default stubbed method for getCloudWatchAlarmNamesByEnvironmentPrefix'
      stubbedDeleteCloudWatchAlarms = sinon.stub(DeployUtils.prototype, 'deleteCloudWatchAlarms').returns q.reject 'default stubbed method for deleteCloudWatchAlarms'
      stubbedCreateCloudWatchAlarms = sinon.stub(DeployUtils.prototype, 'createCloudWatchAlarms').returns q.reject 'default stubbed method for createCloudWatchAlarms'

      stubbedSwapEnvironmentCnames.restore()
      stubbedWaitUntilEnvironmentIsHealthy.withArgs(swapParameters.toNewEnvName).returns q.resolve 'New environment is green'
      stubbedWaitForDnsToPropagate.withArgs(swapParameters.toNewEnvName).returns q.resolve 'DNS is now propagated'
      stubbedGetCloudWatchAlarmNamesByEnvironmentPrefix.withArgs(swapParameters.fromOldEnvName).returns q.resolve existingAlarms
      stubbedGetElbNameByEnvironmentName.withArgs(swapParameters.toNewEnvName).returns q.resolve newElbName
      stubbedDeleteCloudWatchAlarms.withArgs(existingAlarms).returns q.resolve 'Alarms have been deleted'
      stubbedCreateCloudWatchAlarms.withArgs({
        elbName: newElbName
        environmentName: swapParameters.toNewEnvName
        alarms: newAlarms
      }).returns q.resolve 'Alarms created for new environments'

      deployUtils.awsElasticBeanstalk.swapEnvironmentCNAMEs.withArgs({
        SourceEnvironmentName: swapParameters.fromOldEnvName,
        DestinationEnvironmentName: swapParameters.toNewEnvName
      }).returns (params..., cb) -> cb(null, 'awsElasticBeanstalk swapped with correct parameters')

    afterEach ->
      stubbedWaitUntilEnvironmentIsHealthy.restore()
      stubbedWaitForDnsToPropagate.restore()
      stubbedGetCloudWatchAlarmNamesByEnvironmentPrefix.restore()
      stubbedDeleteCloudWatchAlarms.restore()
      stubbedCreateCloudWatchAlarms.restore()

    it 'should call the cname command from AWS with the correct parameters', (next) ->
      deployUtils.swapEnvironmentCnames(swapParameters).should.be.fulfilled.then (response) ->
        expect(response).to.deep.equal 'Alarms created for new environments'
      .should.notify next

  context 'When terminating old environments', ->
    environmentType = 'unit-test'
    environmentsToKill = [
      EnvironmentName: 'testEnv'
    ,
      EnvironmentName: 'testEnv2'
    ]

    beforeEach ->
      stubbedGetAllEnvironmentsWithCname.withArgs("#{applicationName}-#{environmentType}-\\w*").returns q.resolve environmentsToKill

      deployUtils.awsElasticBeanstalk.terminateEnvironment.withArgs(environmentsToKill[0]).returns (params..., cb) ->
        cb(null, {EnvironmentName: environmentsToKill[0].EnvironmentName, Status: "Terminated"})
      deployUtils.awsElasticBeanstalk.terminateEnvironment.withArgs(environmentsToKill[1]).returns (params..., cb) ->
        cb(null, {EnvironmentName: environmentsToKill[1].EnvironmentName, Status: "Terminated"})

    it 'should reject the promise if there no environment type specified', (next) ->
      deployUtils.terminateOldEnviroments().should.be.rejectedWith('No environmentType specified, please provide an environment Type (preview, prod, ...)').and.notify next

    it 'should get the list of environments that match the given RegExp pattern', (next) ->
      deployUtils.terminateOldEnviroments(environmentType).should.be.fulfilled.then (response) ->
        expect(response).to.deep.equal 'Environments are terminated'
      .should.notify next

  context 'When requesting the ELB from an environment Name', ->
    myEnvironmentThatExists = 'myEnvironmentThatExists'
    describedEnvironment = {
      data:
        EnvironmentResources:
          LoadBalancers: [
            Name: 'The ELB Name'
          ]
    }
    beforeEach ->
      stubbedGetElbNameByEnvironmentName.restore()
      deployUtils.awsElasticBeanstalk.describeEnvironmentResources.withArgs({EnvironmentName: myEnvironmentThatExists}).returns (params..., cb) ->
        cb(null, describedEnvironment)

    it 'Should reject if the environment does not exist', (next) ->
      deployUtils.getElbNameByEnvironmentName('envDoesNotExist').should.be.rejectedWith('default stubbed getElbNameByEnvironmentName method').and.notify next

    it 'Should return the ELB name if the environment exists', (next) ->
      deployUtils.getElbNameByEnvironmentName(myEnvironmentThatExists).should.be.fulfilled.then (elbName) ->
        expect(elbName).to.deep.equal ''
      .should.notify next
