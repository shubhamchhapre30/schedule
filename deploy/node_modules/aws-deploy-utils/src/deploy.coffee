AWS  = require 'aws-sdk'
_    = require 'underscore'
q    = require 'q'
log  = require 'winston'
fs   = require 'fs'
Beanstalkify = require 'beanstalkify'

class DeployUtils
  AMAZON_AMI_STACK = '64bit Amazon Linux 2015.03 v2.0.0 running Node.js'
  DEFAULT_TIMEOUT = 120 # seconds

  constructor: ({@elasticBeanstalkAppName, @awsAccessKeyId, @awsSecretAccessKey, @awsSessionToken, @awsRegion}) ->
    for arg of arguments[0]
      if not arguments[0][arg] && arg isnt 'awsSessionToken'
        throw new Error "#{arg} is required"

    @awsCredentials =
      accessKeyId: @awsAccessKeyId
      secretAccessKey: @awsSecretAccessKey
      sessionToken: @awsSessionToken || null
      region: @awsRegion

    @awsElasticBeanstalk = new AWS.ElasticBeanstalk @awsCredentials
    @awsCloudWatch = new AWS.CloudWatch @awsCredentials
    @beanstalkify = new Beanstalkify @awsCredentials

    log.info "AWS Beanstalk and CloudWatch have been setup for '#{@elasticBeanstalkAppName}' application located in '#{@awsRegion}'"

  checkDeploymentParams: (params) ->
    for requiredParam in ['environmentType', 'archiveFilePath', 'beanstalkConfig', 'outputPath']
      if not params[requiredParam]
        throw new Error "--#{requiredParam} options is required"

  getUniqueSuffix: (length) ->
    length ?= 5
    Math.random().toString(36).slice(2).substring(0, length)

  reject = (deferred, error) ->
    if _.isString error
      error = new Error error

    log.error error
    return deferred.reject error

  # Deploy an environment, swap cname with the existing one, and terminate every
  # other environments of the same Type (ie. app-preview-[a-z0-9])
  _blueGreenDeploymentAction: ({existingEnvironment, environmentType, beanstalkifyParams, alarmsConfiguration, outputPath}) ->
    genEnvName = "#{beanstalkifyParams.environmentName}-#{@getUniqueSuffix()}"
    if genEnvName.length >= 23
      genEnvName = "#{environmentType}-#{@getUniqueSuffix(10)}"
      log.info "Proposed Environment Name is too long. Using generated one: #{genEnvName}..."

    beanstalkifyParams.environmentName = genEnvName

    @beanstalkify.deploy beanstalkifyParams
      .then (envDetails) =>
        envJson = JSON.stringify envDetails, null, 2
        q.nfcall fs.writeFile, outputPath, envJson
      .then =>
        @swapEnvironmentCnames {
          fromOldEnvName: existingEnvironment.EnvironmentName
          toNewEnvName: beanstalkifyParams.environmentName
          alarmsConfiguration: alarmsConfiguration
        }
      .then =>
        @terminateOldEnviroments {environmentType}
      .then =>
        return "#{beanstalkifyParams.environmentName} has been deployed (blue/green) successfuly"

  # Deploy an environment and create alarms for it
  _deploymentAction: ({beanstalkifyParams, alarmsConfiguration, outputPath}) ->
    @beanstalkify.deploy beanstalkifyParams
      .then (envDetails) =>
        envJson = JSON.stringify envDetails, null, 2
        q.nfcall fs.writeFile, outputPath, envJson
      .then =>
        @getElbNameByEnvironmentName beanstalkifyParams.environmentName
      .then (elbName) =>
        @createCloudWatchAlarms {
          elbName: elbName
          environmentName: beanstalkifyParams.environmentName
          alarms: beanstalkifyParams.alarmsConfiguration
        }
      .then =>
        return "#{beanstalkifyParams.environmentName} has been deployed successfuly"

  # This is a 'plain' deployment, which will deploy over the top of the specified environment,
  # potentially with some downtime. Useful for just dev/test envrionments where quicker is better
  deploy: ({environmentType, archiveFilePath, beanstalkConfig, outputPath, awsStackName}) ->
    try
      @checkDeploymentParams(arguments[0])
    catch error
      return q.reject error

    beanstalkifyParams =
      archiveFilePath: archiveFilePath
      environmentName: "#{@elasticBeanstalkAppName}-#{environmentType}"
      beanstalkConfig: beanstalkConfig
      awsStackName: awsStackName or AMAZON_AMI_STACK

    log.info "Going to write env data to `#{outputPath}`"
    log.info "Performing a standard deployment of '#{beanstalkifyParams.environmentName}' (#{beanstalkifyParams.environmentName}.elasticbeanstalk.com)"

    return @beanstalkify.deploy beanstalkifyParams
      .then (envDetails) =>
        envJson = JSON.stringify envDetails, null, 2
        q.nfcall fs.writeFile, outputPath, envJson


  # Blue/Green deployment is used when you want to replace an existing environment without downtime.
  # It will first check if the target cname (ie. app-preview, app-prod, ...) is available
  # If the cname is available it will perform a simple deployment and create the alarms for it
  # If the cname is not available it will create a new environment with a uniquelly generated cname
  # and then perfom a cname swap between the exinsting environment and this new environment. Finnaly it
  # will delete the alarms for the old environment, create alarms for the new one and kill every other
  # environment of the same type (ie. kill every other preview environment that are not using the target cname)
  deployBlueGreen: ({environmentType, archiveFilePath, beanstalkConfig, outputPath, awsStackName, alarmsConfiguration}) ->
    try
      @checkDeploymentParams(arguments[0])
    catch error
      return q.reject error

    deferred = q.defer()
    alarmsConfiguration ?= []

    beanstalkifyParams =
      archiveFilePath: archiveFilePath
      environmentName: "#{@elasticBeanstalkAppName}-#{environmentType}"
      beanstalkConfig: beanstalkConfig
      awsStackName: awsStackName or AMAZON_AMI_STACK

    log.info "Performing a blue/green deployment of '#{beanstalkifyParams.environmentName}' (#{beanstalkifyParams.environmentName}.elasticbeanstalk.com)"
    promise = @getEnvironmentWithCname beanstalkifyParams.environmentName

    # There's no env, create new from scratch
    failCB = (error) =>
      log.info "The following cname '#{beanstalkifyParams.environmentName}.elasticbeanstalk.com' is available..."
      @_deploymentAction {beanstalkifyParams, alarmsConfiguration, outputPath}
        .then (data) ->
          deferred.resolve data
        .catch (error) ->
          deferred.reject error

    # There's already an env, so do the full blue/green deploy
    successCB = (existingEnvironment) =>
      log.info "The following cname '#{beanstalkifyParams.environmentName}.elasticbeanstalk.com' is NOT available..."
      @_blueGreenDeploymentAction {existingEnvironment, environmentType, beanstalkifyParams, alarmsConfiguration, outputPath}
        .then deferred.resolve
        .catch deferred.reject

    promise.done successCB, failCB

    return deferred.promise

  # Generate a unique environment name and cname base on the the environment type
  # ie. if environmentType is "preview" then the name and cname of this new environment will be:
  #    - name: <APPLICATION_NAME>-preview-98ej5
  #    - cname: <APPLICATION_NAME>-preview-98ej5.elasticbeanstalk.com
  #
  deployUniqueEnvironment: ({environmentType, archiveFilePath, beanstalkConfig, outputPath, awsStackName}) ->
    try
      @checkDeploymentParams(arguments[0])

      genEnvName = "#{@elasticBeanstalkAppName}-#{environmentType}-#{@getUniqueSuffix()}"
      if genEnvName.length >= 23
        genEnvName = "#{environmentType}-#{@getUniqueSuffix(10)}"
        log.info "Proposed Environment Name is too long. Using generated one: #{genEnvName}..."

      beanstalkifyParams =
        archiveFilePath: archiveFilePath
        environmentName: genEnvName
        beanstalkConfig: beanstalkConfig
        outputPath: outputPath
        awsStackName: awsStackName or AMAZON_AMI_STACK

      log.info "Performing a unique deployment of '#{beanstalkifyParams.environmentName}' (#{beanstalkifyParams.environmentName}.elasticbeanstalk.com)"

      return @beanstalkify.deploy beanstalkifyParams
        .then (envDetails) =>
          envJson = JSON.stringify envDetails, null, 2
          q.nfcall fs.writeFile, outputPath, envJson
          return "#{beanstalkifyParams.environmentName} has been deployed successfuly"
    catch error
      return q.reject error

  getAllEnvironmentsWithCname: (cnameRegexPattern) ->
    log.info "Getting environments where CNAME matching the following Regex (#{cnameRegexPattern}.elasticbeanstalk.com) in #{@elasticBeanstalkAppName}"
    q.nfcall @awsElasticBeanstalk.describeEnvironments.bind(@awsElasticBeanstalk), {ApplicationName: @elasticBeanstalkAppName, IncludeDeleted: false}
      .then (data) =>
        matches = _.filter data.Environments, (e) -> new RegExp("#{cnameRegexPattern}.elasticbeanstalk.com").test(e.CNAME)
        log.info "#{matches.length} environments found matching the RegExp"
        return matches

  getEnvironmentWithCname: (cnameRegexPattern) ->
    @getAllEnvironmentsWithCname cnameRegexPattern
    .then (environments) ->
      if environments.length is 0
        return q.reject new Error "Environment '#{cnameRegexPattern}' not found!"
      return environments[0]

  waitUntilEnvironmentIsHealthy: (envName, deferred) ->
    deferred ?= q.defer()
    log.info "Waiting until new environment is ready and green..."

    @awsElasticBeanstalk.describeEnvironments {EnvironmentNames: [envName]}, (error, data) =>
      if error
        return reject deferred, error

      if data.Environments[0].Status is "Ready"
        if data.Environments[0].Health is "Green"
          return deferred.resolve data.Environments[0]
        else
          return deferred.reject "Environment is #{data.Environments[0].Health}"

      setTimeout (=> @waitUntilEnvironmentIsHealthy envName, deferred), 5*1000

    return deferred.promise

  waitForDnsToPropagate: (environmentName) ->
    log.info "Waiting for 60 seconds for the DNS of '#{environmentName}' to propagate..."
    return q.delay 60*1000

  # When performing a cname swap, we want to swap the current "preview", "prod", ...
  # with our new environment that we just created. ie.
  #    jumpin-preview-9j3de.elb.com  -> jumpin-preview.elb.com
  #
  # This cname swap method is doing exactly that, but it's also deleting the alarms
  # of the old environment and create the alarms for the new environment.
  # This is not checking if the environments exist before to perform the cname swap
  # because logically they should
  swapEnvironmentCnames: ({fromOldEnvName, toNewEnvName, alarmsConfiguration}) ->
    log.info "Swapping CNAMEs from #{fromOldEnvName} to #{toNewEnvName}..."

    q.nfcall @awsElasticBeanstalk.swapEnvironmentCNAMEs.bind(@awsElasticBeanstalk), {SourceEnvironmentName: fromOldEnvName, DestinationEnvironmentName: toNewEnvName}
      .then =>
        # TODO: this has no timeout, so its possible for it to run infinitely
        @waitUntilEnvironmentIsHealthy toNewEnvName
      .then =>
        @waitForDnsToPropagate toNewEnvName
      .then =>
        # Get the alarms for the previous environment
        @getCloudWatchAlarmNamesByEnvironmentPrefix fromOldEnvName
      .then (currentAlarms) =>
        # Delete alarms for previous environment
        q.all [
          @deleteCloudWatchAlarms currentAlarms
          @getElbNameByEnvironmentName toNewEnvName
        ]
      .then ([deletedAlarms, elbName]) =>
        # Create alarms for the new environment
        @createCloudWatchAlarms
          elbName: elbName
          environmentName: toNewEnvName
          alarms: alarmsConfiguration

  # When performing a cname swap, we want to swap the current "preview", "prod", ...
  # with our new environment that we just created. ie.
  #    jumpin-preview-9j3de.elb.com  -> jumpin-preview.elb.com
  #
  # This cname swap method is doing exactly that, but it's also deleting the alarms
  # of the old environment and create the alarms for the new environment.
  # This is not checking if the environments exist before to perform the cname swap
  # because logically they should
  swapEnvironmentCnamesByCname: ({fromOldEnvCName, toNewEnvCName, alarmsConfiguration}) ->
    log.info "Swapping CNAMEs from #{fromOldEnvCName} to #{toNewEnvCName}..."
    oldEnv = null
    newEnv = null

    @getAllEnvironmentsWithCname "\\w*"
      .then (projectEnvironments) =>
        oldEnv = _.find projectEnvironments, (e) -> fromOldEnvCName == e.CNAME
        newEnv = _.find projectEnvironments, (e) -> toNewEnvCName == e.CNAME

        if not oldEnv or not newEnv
          return q.reject "#{fromOldEnvCName} or #{toNewEnvCName} could not be found in application #{@elasticBeanstalkAppName}"

        q.nfcall @awsElasticBeanstalk.swapEnvironmentCNAMEs.bind(@awsElasticBeanstalk), {SourceEnvironmentName: oldEnv.EnvironmentName, DestinationEnvironmentName: newEnv.EnvironmentName}
      .then =>
        # TODO: this has no timeout, so its possible for it to run infinitely
        @waitUntilEnvironmentIsHealthy newEnv.EnvironmentName
      .then =>
        @waitForDnsToPropagate newEnv.EnvironmentName
      .then =>
        # Get the alarms for the previous environment
        @getCloudWatchAlarmNamesByEnvironmentPrefix oldEnv.EnvironmentName
      .then (currentAlarms) =>
        # Delete alarms for previous environment
        q.all [
          @deleteCloudWatchAlarms currentAlarms
          @getElbNameByEnvironmentName newEnv.EnvironmentName
        ]
      .then ([deletedAlarms, elbName]) =>
        # Create alarms for the new environment
        @createCloudWatchAlarms
          elbName: elbName
          environmentName: newEnv.EnvironmentName
          alarms: alarmsConfiguration

  terminateEnvironment: ({environmentName, safely}) ->
    safely ?= true

    log.info "Terminating Environment named #{environmentName}..."

    @getAllEnvironmentsWithCname "\\w*"
      .then (projectEnvironments) =>
        environmentToTerminate = _.find projectEnvironments, (e) -> environmentName == e.EnvironmentName

        if not environmentToTerminate
          return q.reject "Environment #{environmentName} could not be found in #{@elasticBeanstalkAppName}"

        if safely is true
          log.info "Performing safe check before terminating..."
          if new RegExp("#{@elasticBeanstalkAppName}-(prod|prev|stag|preview|production|staging|uat).elasticbeanstalk.com").test(environmentToTerminate.CNAME)
            return q.reject "You are trying the terminate a protected Environment '#{environmentName}'"

        q.nfcall @awsElasticBeanstalk.terminateEnvironment.bind(@awsElasticBeanstalk), {EnvironmentName: environmentName}

  # Terminates ALL environments of a certain type
  # ie. if the type is preview, then we'll look for all environments of the current AWS Application
  # where the cname matches the following regext pattern: "jumpin-preview-[something]"
  # so this pattern is not including "jumpin-preview" (the only server we don't want to kill)
  # Once we got the list of servers, we kill them all
  terminateOldEnviroments: ({environmentType}) ->
    if not environmentType
      return q.reject 'No environmentType specified, please provide an environment Type (preview, prod, ...)'

    regexPattern = ".*#{environmentType}-\\w*"
    promises = []

    @getAllEnvironmentsWithCname regexPattern
      .then (environments) =>
        promises = environments.map (environment) =>
          @terminateEnvironment {environmentName: environment.EnvironmentName}

        q.allSettled(promises).then (results) ->
          for result in results
            if result.state is 'fulfilled'
              log.info "Environment #{result.value.EnvironmentName} has been terminated (#{result.value.Status})"
            else
              log.error "Environment #{result.value.EnvironmentName} has been terminated (#{result.value.Status})"
          return "Environments are terminated"
      .catch (error) ->
        log.info "No environments found to kill for the following type: '#{environmentType}'"

  getElbNameByEnvironmentName: (environmentName) ->
    log.info "Getting Elastic Load Blancer by environment name (#{environmentName})..."

    q.nfcall @awsElasticBeanstalk.describeEnvironmentResources.bind(@awsElasticBeanstalk), {EnvironmentName: environmentName}
      .then (data) =>
        elbName = data?.EnvironmentResources?.LoadBalancers?[0]?.Name
        if not elbName
          return q.reject "ElasticLoadBlancer resource is not available for this environment '#{environmentName}'"
        return elbName

  getCloudWatchAlarmNamesByEnvironmentPrefix: (environmentName) ->
    log.info "Getting CloudWatch Alarms by environment prefix (#{environmentName}-*)..."

    q.nfcall @awsCloudWatch.describeAlarms.bind(@awsCloudWatch), {AlarmNamePrefix: "#{environmentName}-"}
      .then (data) =>
        _.pluck data.MetricAlarms, 'AlarmName'

  deleteCloudWatchAlarms: (alarmNames) ->
    log.info "Deleting CloudWatch Alarms..."

    q.nfcall @awsCloudWatch.deleteAlarms.bind(@awsCloudWatch), {AlarmNames: alarmNames}
      .then (data) =>
        log.info "Deleted CloudWatch Alarms: #{alarmNames.join(', ')}"

  # (object) alarm:
  #   namespace: 'AWS/ELB'
  #   metricName: 'Latency'
  #   comparisonOperator: 'GreaterThanOrEqualToThreshold'
  #   evaluationPeriods: 3
  #   period: 60
  #   statistic: 'Average'
  #   threshold: 1.5
  #   alarmActions: ['arn:aws:sns:ap-southeast-2:912262358979:jump-in-website-production']
  createCloudWatchAlarm: ({elbName, environmentName, alarm}) ->
    log.info "Creating CloudWatch Alarm: #{environmentName}-#{alarm.metricName} for elb: #{elbName}..."

    alarmConfiguration =
      AlarmName: "#{environmentName}-#{alarm.metricName}"
      ActionsEnabled: true
      AlarmActions: alarm.alarmActions
      MetricName: alarm.metricName
      Namespace: alarm.namespace
      Statistic: alarm.statistic
      Dimensions: [
        Name: 'elbName'
        Value: elbName
      ]
      Period: alarm.period
      EvaluationPeriods: alarm.evaluationPeriods
      Threshold: alarm.threshold
      ComparisonOperator: alarm.comparisonOperator

    q.nfcall @awsCloudWatch.putMetricAlarm.bind(@awsCloudWatch), alarmConfiguration
      .then (response) =>
        return "Created CloudWatch Alarm: #{alarmConfiguration.AlarmName}"

  createCloudWatchAlarms: ({elbName, environmentName, alarms}) ->
    if not alarms
      log.info "No alarms to create for #{environmentName}"
      return

    log.info "Creating CloudWatch Alarms for elb: #{elbName}..."

    promises = alarms.map (alarm) ->
      createCloudWatchAlarm
        elbName: elbName
        environmentName: environmentName
        alarm: alarm

    q.allSettled(promises).then (results) ->
      for result in results
        log.info result.value

module.exports = DeployUtils
